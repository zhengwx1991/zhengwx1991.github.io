{"pages":[],"posts":[{"title":"IDEA常用命令","text":"代码整理，代码格式化 Ctrl+Alt+L 全局搜素 Ctrl+Shift+F 代码切换大小写 Ctrl+Shift+U 添加getter、setter方法 Alt+Insert 上移、下移代码 Alt+Shift+Up/Down 删除一行 Ctrl+Y","link":"/2018/03/09/IDEA常用命令/"},{"title":"Linux安装Jenkins","text":"下载Jenkins到本地https://jenkins.io/zh/download/ 下载长期支持版本 (LTS)的war包版本《jenkins.war》将war包上传到tomcat的webapps目录","link":"/2018/09/29/Linux安装Jenkins/"},{"title":"Linux安装Redis","text":"登陆Redis官网，找到最新版的下载地址：https://redis.io/download登陆到Linux1、下载wget http://download.redis.io/releases/redis-5.0.5.tar.gz2、解压tar -zxvf redis-5.0.5.tar.gz 3、安装GCCyum install -y gcc g++ gcc-c++4、进入目录cd redis-5.0.55、编译make6、安装make install7、创建新目录mkdir -p /usr/local/redis/bin mkdir -p /usr/local/redis/etc8、将安装所得文件redis.conf移入新建文件夹etc中mv redis.conf /usr/local/redis/etc9、进入src目录cd src10、将安装所得以下文件移入新建文件夹bin中mv mkreleasehdr.sh /usr/local/redis/bin mv redis-benchmark /usr/local/redis/bin mv redis-check-aof /usr/local/redis/bin mv redis-check-rdb /usr/local/redis/bin mv redis-cli /usr/local/redis/bin mv redis-server /usr/local/redis/bin11、启动Redis服务cd /usr/local/redis/bin redis-server12、设置后台运行和密码vi /usr/local/redis/etc/redis.conf // daemonize on 改为yes daemonize yes // 找到# requirepass foobared，在下边添加 requirepass 123456 protected-mode no bind 0.0.0.0远程设置，防火墙// 向防火墙添加 Redis 端口 firewall-cmd --zone=public --add-port=6379/tcp --permanent // 刷新防火墙规则 firewall-cmd --reload // 验证端口,查询防火墙开放端口 firewall-cmd --zone=public --list-port // 重启防火墙 systemctl restart firewalld.serviceRedis常用命令// 查看redis状态 ps -ef|grep redis // 重启redis cd /usr/local/redis/bin ./redis-server /usr/local/redis/etc/redis.conf ./redis-cli -h 192.168.128.130 -p 6379 -a 123456","link":"/2018/09/09/Linux安装Redis/"},{"title":"Linux安装GitLab","text":"防火墙开启http ssh端口yum install lokkit yum install curl openssh-server openssh-clients postfix cronie -y service postfix start chkxonfig postfix start lokkit -s http -s ssh 添加gitlab仓库并安装curl -sS http://packages.gitlab.cc/install/gitlab-ce/script.rpm.sh | sudo bash sudo yum install gitlab-ce启动gitlabgitlab-ctl reconfigure vim /etc/gitlab/gitlab.rb 修改external_url gitlab-ctl reconfigure gitlab-ctl restart配置防火墙vim /etc/sysconfig/iptables yy复制p粘贴，开放8899端口","link":"/2018/09/26/Linux安装gitlab/"},{"title":"Linux安装RabbitMQ","text":"Linux安装RabbitMQ安装Erlang下载包 wget http://www.rabbitmq.com/releases/erlang/erlang-19.0.4-1.el7.centos.x86_64.rpm 解压包 rpm -ivh erlang-19.0.4-1.el7.centos.x86_64.rpm 安装 yum -y install erlang 查看版本，验证是否安装成功 erl -version 安装RabbitMQ下载包 wget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.6/rabbitmq-server-3.6.6-1.el7.noarch.rpm 安装 yum install rabbitmq-server-3.6.6-1.el7.noarch.rpm 完成后启动服务(停止、重启) service rabbitmq-server start service rabbitmq-server stop service rabbitmq-server restart 可以查看服务状态 service rabbitmq-server status 开机启动 chkconfig rabbitmq-server on 后台运行 rabbitmq-server -detached 设置配置文件 cd /etc/rabbitmq cp /usr/share/doc/rabbitmq-server-3.6.6/rabbitmq.config.example /etc/rabbitmq/ mv rabbitmq.config.example rabbitmq.config 开启用户远程访问 vi /etc/rabbitmq/rabbitmq.config 找到64行，去掉下边代码前的%%和， {loopback_users, []} 开启防火墙端口，并重启防火墙 firewall-cmd --zone=public --add-port=15672/tcp --permanent firewall-cmd --reload","link":"/2018/09/09/Linux安装RabbitMQ/"},{"title":"Linux安装JDK、MAVEN","text":"下载JDK1.8下载.tar.gz后缀的文件到本地，下载完将文件拷入服务器中 https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html 解压解压安装包并移动到/usr/local/路径下 tar -zxvf jdk-8u221-linux-i586.tar.gz -C /usr/local/更改环境变量vi /etc/profile 在最下面，按i进入insert模式，添加一下内容 JAVA_HOME=/usr/local/jdk1.8.0_211 export JAVA_HOME CLASSPATH=.:$JAVA_HOME/lib export CLASSPATH PATH=$PATH:$JAVA_HOME/bin:$CLASSPATH export PATH 按esc进入命令行模式，再输入:wq 回车保存退出 激活配置 source /etc/profile查看版本号确认成功java -version 系统出现如下提示，表示安装成功 java version &quot;1.8.0_211&quot; Java(TM) SE Runtime Environment (build 1.8.0_211-b12) Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode)下载mavenhttps://maven.apache.org/download.cgi 下载.tar.gz后缀的文件到本地，下载完将文件拷入服务器中解压解压安装包并移动到/usr/local/路径下 tar -zxvf apache-maven-3.6.1-bin.tar.gz -C /usr/local/更改环境变量vi /etc/profile 在最下面，按i进入insert模式，添加一下内容 MAVEN_HOME=/usr/local/apache-maven-3.6.1 export MAVEN_HOME PATH=$PATH:$MAVEN_HOME/bin export PATH 按esc进入命令行模式，再输入:wq 回车保存退出 激活配置 source /etc/profile查看版本号确认成功mvn -version 系统出现如下提示，表示安装成功 Apache Maven 3.6.1 (d66c9c0b3152b2e69ee9bac180bb8fcc8e6af555; 2019-04-05T03:00:29+08:00) Maven home: /usr/local/apache-maven-3.6.1 Java version: 1.8.0_211, vendor: Oracle Corporation, runtime: /usr/local/jdk1.8.0_211/jre Default locale: en_US, platform encoding: UTF-8","link":"/2018/09/09/Linux安装jdk_Maven/"},{"title":"Linux安装sonarQube","text":"下载与上传https://www.sonarqube.org/ 把zip文件上传到linux解压unzip sonarqube-7.8.zip // 移动到/usr/local/目录 mv sonarqube-7.8 /usr/local/","link":"/2018/09/09/Linux安装sonarQube/"},{"title":"Linux常用命令","text":"文件操作：// 打开文件夹 cd /home/admin // 返回上一级 cd .. // 创建文件夹 mkdir xxx // 复制文件 cp 要复制的文件名 目标目录 // 剪切文件 mv 要复制的文件名 目标目录 // 删除文件夹命令 rm -rf 要删除的文件夹名（注：-f为强制删除，-r为文件夹） // 删除文件命令 rm -f 要删除的文件名","link":"/2018/09/09/Linux常用命令/"},{"title":"博客相关","text":"Markdown软件Typora：清爽简约，使用较为方便，所见即所得，插入图片、表格也很方便。官网：https://www.typora.io 图床目前使用免费，每个文件最多5 MB。每个请求最多10个文件。使用也很方便https://sm.ms 博客搭建hexo官网：https://hexo.io/zh-cn/docs/主题文档：https://blog.zhangruipeng.me/hexo-theme-icarus/categories/搭建文档：https://blog.csdn.net/sinat_37781304/article/details/82729029","link":"/2019/08/12/README/"},{"title":"SpringBoot系列--热部署devtools","text":"官方文档https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#using-boot-devtools pom文件添加依赖12345678910111213141516171819202122&lt;dependencies&gt; &lt;!--热部署--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;!--特别注意：配置devtools--&gt; &lt;!--如果没有该项配置，这个devtools不会起作用，即应用不会restart--&gt; &lt;configuration&gt; &lt;fork&gt;true&lt;/fork&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 完成以上步骤即可使用热部署 个性化配置 修改application.yml配置文件 1234567891011spring: devtools: restart: #热部署生效，默认为true enabled: true #设置重启的目录 additional-paths: src/main/java #classpath目录下的WEB-INF文件夹内容修改不重启 exclude: WEB-INF/** # 指定触发文件，当该文件修改时才会重启 trigger-file: trigger.txt 在src\\main\\resources创建trigger.txt文件在trigger.txt文件中写入version=1，每次需要重启系统时，修改该文件里边的数字即可，一是避免每次保存后台文件时系统频繁重启的问题，二是方便自己版本管理，如果不需要则trigger.txt文件里边的内容自定义即可。 IDEA下不生效的问题 Ctrl+Alt+S打开Settings 12找到Build, Execution, Deployment--&gt;&gt;Compiler 勾选Build project automatically Ctrl+Shift+Alt+/或者Alt+Shift+A点击 Registry… 勾选compiler.automake.allow.when.app.running","link":"/2018/09/01/SpringBoot系列-1-热部署/"},{"title":"SpringBoot系列--个性化启动banner","text":"项目地址https://github.com/zhengwx1991/spring-boot-demo.git 官方文档https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-banners 设置个性化启动banner banner生成网站https://www.bootschool.net/ascii 修改application.yml 1234spring: banner: # 个性化banner文件地址 location: banner.txt 在resources目录下增加banner.txt在banner.txt写入自己需要自定义的banner，如下： 123456 ____ __ __ ____ __ __ _ ____ _____ / ___| \\ \\ / / / ___| \\ \\ / / / \\ | _ \\ | ____| \\___ \\ \\ V / \\___ \\ \\ \\ /\\ / / / _ \\ | |_) | | _| ___) | | | ___) | \\ V V / / ___ \\ | _ &lt; | |___ |____/ |_| |____/ \\_/\\_/ /_/ \\_\\ |_| \\_\\ |_____|======================= XX系统欢迎您 ! =======================","link":"/2018/09/02/SpringBoot系列-2-个性化启动banner/"},{"title":"SpringBoot系列--定时任务、异步任务","text":"项目地址https://github.com/zhengwx1991/spring-boot-demo.git 定时任务常见定时任务 Java自带的java.util.Timer类timer:配置比较麻烦，时间延后问题timertask:不推荐 Quartz框架配置更简单xml或者注解 SpringBoot自带的schedule SpringBoot使用注解方式开启定时任务 启动类里面 @EnableScheduling开启定时任务，自动扫描 123456789101112import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableScheduling;@SpringBootApplication// 启动类里面 @EnableScheduling开启定时任务，自动扫描@EnableSchedulingpublic class SpringBootDemoApplication { public static void main(String[] args) { SpringApplication.run(SpringBootDemoApplication.class, args); }} 定时任务业务类 加注解 @Component被容器扫描 定时执行的方法加上注解 @Scheduled(fixedRate=2000) 定期执行一次 1234567891011121314import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;import java.util.Date;@Componentpublic class TimingTask { private Logger logger = LoggerFactory.getLogger(this.getClass()); @Scheduled(fixedRate = 200000) public void start(){ logger.info(\"执行了定时任务，时间：\"+new Date()); }} SpringBoot常用定时任务配置 cron 定时任务表达式 @Scheduled(cron=”*/1 * * * * *”) 表示每秒crontab 工具 https://tool.lu/crontab/ fixedRate: 定时多久执行一次（上一次开始执行时间点后xx秒再次执行；） fixedDelay: 上一次执行结束时间点后xx秒再次执行 fixedDelayString: 字符串形式，可以通过配置文件指定 异步任务什么是异步任务和使用场景适用于处理log、发送邮件、短信……等 异步任务开发 启动类里面使用@EnableAsync注解开启功能，自动扫描 12345678@SpringBootApplication// 开启异步任务@EnableAsyncpublic class SpringBootDemoApplication { public static void main(String[] args) { SpringApplication.run(SpringBootDemoApplication.class, args); }} 定义异步任务类并使用@Component标记组件被容器扫描,异步方法加上@Async 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.scheduling.annotation.Async;import org.springframework.scheduling.annotation.AsyncResult;import org.springframework.stereotype.Component;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;@Component@Asyncpublic class AsyncTask { private Logger logger = LoggerFactory.getLogger(this.getClass()); public void task1() throws InterruptedException { long start = System.currentTimeMillis(); // 休眠 TimeUnit.SECONDS.sleep(1); long end = System.currentTimeMillis(); logger.info(\"执行了异步任务1，时间：\"+(end-start)); } public void task2() throws InterruptedException { long start = System.currentTimeMillis(); TimeUnit.SECONDS.sleep(2); long end = System.currentTimeMillis(); logger.info(\"执行了异步任务2，时间：\"+(end-start)); } public void task3() throws InterruptedException { long start = System.currentTimeMillis(); TimeUnit.SECONDS.sleep(3); long end = System.currentTimeMillis(); logger.info(\"执行了异步任务3，时间：\"+(end-start)); } // 以下三个方法为：获取异步结果 public Future&lt;String&gt; task4() throws InterruptedException { long start = System.currentTimeMillis(); TimeUnit.SECONDS.sleep(2); long end = System.currentTimeMillis(); String msg = \"执行了异步任务4，时间：\"+(end-start); logger.info(msg); return new AsyncResult&lt;String&gt;(msg); } public Future&lt;String&gt; task5() throws InterruptedException { long start = System.currentTimeMillis(); TimeUnit.SECONDS.sleep(3); long end = System.currentTimeMillis(); String msg = \"执行了异步任务5，时间：\"+(end-start); logger.info(msg); return new AsyncResult&lt;String&gt;(msg); } public Future&lt;String&gt; task6() throws InterruptedException { long start = System.currentTimeMillis(); TimeUnit.SECONDS.sleep(1); long end = System.currentTimeMillis(); String msg = \"执行了异步任务6，时间：\"+(end-start); logger.info(msg); return new AsyncResult&lt;String&gt;(msg); }} 调用异步任务 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.concurrent.Future;@RestController@RequestMapping(\"api/v1/async\")public class AsyncTaskController { private Logger logger = LoggerFactory.getLogger(this.getClass()); @Autowired private AsyncTask asyncTask; /** * 调用异步任务 * @return * @throws InterruptedException */ @RequestMapping(\"async_task\") public Object asyncTask() throws InterruptedException { long start = System.currentTimeMillis(); asyncTask.task1(); asyncTask.task2(); asyncTask.task3(); long end = System.currentTimeMillis(); logger.info(\"执行总耗时：\"+(end-start)); return \"异步任务\"; } /** * 调用异步任务，并获取异步任务的结果 * @return * @throws InterruptedException */ @RequestMapping(\"async_task_result\") public Object asyncTaskResult() throws InterruptedException { long start = System.currentTimeMillis(); Future&lt;String&gt; task4 = asyncTask.task4(); Future&lt;String&gt; task5 = asyncTask.task5(); Future&lt;String&gt; task6 = asyncTask.task6(); // 死循环 for (;;){ // 判断这三个任务是否全部完成，如果完成则跳出循环 if (task4.isDone() &amp;&amp; task5.isDone() &amp;&amp; task6.isDone()){ break; } } long end = System.currentTimeMillis(); logger.info(\"执行总耗时：\"+(end-start)); return \"异步任务\"; }} 注意点 要把异步任务封装到类里面，不能直接写到Controller 增加Future 返回结果 AsyncResult(“task执行完成”); 如果需要拿到结果 需要判断全部的 task.isDone() 通过注入方式，注入到controller里面，如果测试前后区别则改为同步则把Async注释掉","link":"/2018/09/03/SpringBoot系列-3-定时-异步任务/"},{"title":"SpringBoot系列--多环境配置","text":"项目地址https://github.com/zhengwx1991/spring-boot-demo.git 多环境配置不同环境使用不同配置：例如数据库配置，在开发的时候，我们一般用开发数据库，而在生产环境的时候，我们是用正式的数据 多环境配置开发创建多环境配置文件，示例如下：spring boot允许通过命名约定按照一定的格式(application-{profile}.properties)来定义多个配置文件。创建多环境配置文件时一定要遵循规范。 新建application-dev.yml 12test: url: dev.com 新建application-test.yml 12test: url: test.com 修改application.yml 1234567spring: # springboot多环境配置，指定读取的配置文件，主要名字要与配置文件名字吻合 profiles: active: test# 如果上边不指定读取的文件，则系统会读取application.yml里边对应的配置test: url: localhost 读取配置，验证是否成功 123456789101112131415161718192021222324import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;@RestController@RequestMapping(\"api/v1\")public class DemoController { /** * 获取配置信息 */ @Value(\"${test.url}\") private String url; /** * 读取springboot多环境配置信息 * @return */ @RequestMapping(\"many_env\") public Object manyEnv(){ return url; }}","link":"/2018/09/05/SpringBoot系列-5-多环境配置/"},{"title":"SpringBoot系列--日志LogBack","text":"基本介绍常用日志组件slf4j、log4j、logback、common-logging等 logback介绍基于Log4j基础上大量改良，不能单独使用，推荐配合日志框架SLF4J来使用logback当前分成三个模块：logback-core,logback-classic和logback-access;logback-core是其它两个模块的基础模块 Logback的核心对象：Logger：日志记录器Appender：指定日志输出的目的地，目的地可以是控制台，文件Layout：日志布局 格式化日志信息的输出 日志级别：DEBUG &lt; INFO &lt; WARN &lt; ERROR1234567891011121314151617181920212223242526===========log4j示例=========== ### 设置###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n### 输出DEBUG 级别以上的日志到=D://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = D://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=D://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d{yyyy-MM-dd HH:mm:ss} [ %t:%r ] - [ %p ] %m%n ===========logback============ Log4j日志转换为logback在线工具https://logback.qos.ch/translator/支持log4j.properties转换为logback.xml,不支持 log4j.xml转换为logback.xml SpringBoot整合Logback官方文档https://docs.spring.io/spring-boot/docs/2.1.0.BUILD-SNAPSHOT/reference/htmlsingle/#boot-features-logging 各个配置介绍官方文档https://logback.qos.ch/manual/index.html XML配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;configuration&gt; &lt;appender name=\"consoleApp\" class=\"ch.qos.logback.core.ConsoleAppender\"&gt; &lt;layout class=\"ch.qos.logback.classic.PatternLayout\"&gt; &lt;pattern&gt; %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n &lt;/pattern&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;appender name=\"fileInfoApp\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.LevelFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;DENY&lt;/onMatch&gt; &lt;onMismatch&gt;ACCEPT&lt;/onMismatch&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!-- 滚动策略 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 路径 --&gt; &lt;fileNamePattern&gt;app_log/log/app.info.%d.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;appender name=\"fileErrorApp\" class=\"ch.qos.logback.core.rolling.RollingFileAppender\"&gt; &lt;filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;/filter&gt; &lt;encoder&gt; &lt;pattern&gt; %date{yyyy-MM-dd HH:mm:ss.SSS} %-5level[%thread]%logger{56}.%method:%L -%msg%n &lt;/pattern&gt; &lt;/encoder&gt; &lt;!-- 设置滚动策略 --&gt; &lt;rollingPolicy class=\"ch.qos.logback.core.rolling.TimeBasedRollingPolicy\"&gt; &lt;!-- 路径 --&gt; &lt;fileNamePattern&gt;app_log/log/app.err.%d.log&lt;/fileNamePattern&gt; &lt;!-- 控制保留的归档文件的最大数量，超出数量就删除旧文件，假设设置每个月滚动， 且&lt;maxHistory&gt; 是1，则只保存最近1个月的文件，删除之前的旧文件 --&gt; &lt;MaxHistory&gt;1&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;/appender&gt; &lt;!--控制总的输出级别,该级别以上的信息都会被输出：DEBUG &lt; INFO &lt; WARN &lt; ERROR--&gt; &lt;root level=\"INFO\"&gt; &lt;appender-ref ref=\"consoleApp\"/&gt; &lt;appender-ref ref=\"fileInfoApp\"/&gt; &lt;appender-ref ref=\"fileErrorApp\"/&gt; &lt;/root&gt;&lt;/configuration&gt;","link":"/2018/09/04/SpringBoot系列-4-日志/"},{"title":"SpringBoot系列--HTTP请求配置","text":"项目地址https://github.com/zhengwx1991/spring-boot-demo.git 常用注解，注解等效12345678@RestController和@RequestMapping是springMVC的注解，不是springboot特有的 @RestController = @Controller+@ResponseBody @SpringBootApplication = @Configuration+@EnableAutoConfiguration+@ComponentScan@GetMapping = @RequestMapping(method = RequestMethod.GET)@PostMapping = @RequestMapping(method = RequestMethod.POST)@PutMapping = @RequestMapping(method = RequestMethod.PUT)@DeleteMapping = @RequestMapping(method = RequestMethod.DELETE) HTTP请求GET请求1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253 //单一参数 @RequestMapping(path = \"/{id}\", method = RequestMethod.GET) public String getUser(@PathVariable String id ) { } // 可以同时指定多个参数 @RequestMapping(path = \"/{depid}/{userid}\", method = RequestMethod.GET) public String getUser(@PathVariable(\"depid\") String departmentID,@PathVariable(\"userid\") String userid){ } /** * 默认值，如果接口没传该参数，则使用默认值 * 参数是否必填验证（不是强项,可以由前端或者拦截器等验证） * page是前端传过来的对应值，也可以不设置 * @param from * @param size * @return */ @GetMapping(\"page_user2\") public Object pageUser2(@RequestParam(defaultValue = \"0\", name = \"page\", required = true) int from, int size){ params.clear(); params.put(\"from\", from); params.put(\"size\", size); return params; }/** * bean对象传参 * 注意：1、注意需要指定http头为content-type为application/json * 2、使用body传输数据 * 3、只能用post提交，所以注解不是@GetMapping而是@RequestMapping * @param user * @return */ @RequestMapping(\"save_user\") public Object saveUser(@RequestBody User user){ } /** * 获取http请求头信息，比如鉴权 * @param accessToken * @param id * @return */ @GetMapping(\"get_header\") public Object getHeader(@RequestHeader(\"access_token\") String accessToken, String id){ params.clear(); params.put(\"accessToken\", accessToken); params.put(\"id\", id); return params; } 其他请求12345678910111213141516171819202122232425262728293031323334353637/** * post提交，一般用于登陆，表单提交等 * @param id * @param pwd * @return */ @PostMapping(\"post\") public Object post(String id, String pwd){ params.clear(); params.put(\"id\", id); params.put(\"pwd\", pwd); return params; } /** * put提交，一般用于更新 * @param id * @return */ @PutMapping(\"put\") public Object put(String id){ params.clear(); params.put(\"id\", id); return params; } /** * DeleteMapping提交，删除 * @param id * @return */ @DeleteMapping(\"del\") public Object del(String id){ params.clear(); params.put(\"id\", id); return params; } postman接口详见src/main/resources/postman/HTTP请求.postman_collection.json","link":"/2018/09/06/SpringBoot系列-6-http请求配置/"},{"title":"SpringCloud系列——注册中心Eureka","text":"官方文档http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#spring-cloud-eureka-server 什么是注册中心理解注册中心：服务管理,核心是有个服务注册表，心跳机制动态维护 服务提供者provider: 启动的时候向注册中心上报自己的网络信息 服务消费者consumer: 启动的时候向注册中心上报自己的网络信息，拉取provider的相关网络信息 为什么要用： 微服务应用和机器越来越多，调用方需要知道接口的网络地址，如果靠配置文件的方式去控制网络地址，对于动态新增机器，维护带来很大问题 主流的注册中心： zookeeper、Eureka、consul、etcd 等 什么是CAPCAP定理 指的是在一个分布式系统中，Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可同时获得。 一致性（C） 在分布式系统中的所有数据备份，在同一时刻是否同样的值。（所有节点在同一时间的数据完全一致，越多节点，数据同步越耗时） 可用性（A） 负载过大后，集群整体是否还能响应客户端的读写请求。（服务一直可用，而且是正常响应时间） 分区容错性（P） 分区容忍性，就是高可用性，一个节点崩了，并不影响其它的节点（100个节点，挂了几个，不影响服务，越多机器越好） CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。而由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是我们必须需要实现的。所以我们只能在一致性和可用性之间进行权衡 CA 满足的情况下，P不能满足的原因： 数据同步(C)需要时间，也要正常的时间内响应(A)，那么机器数量就要少，所以P就不满足 CP 满足的情况下，A不能满足的原因： 数据同步(C)需要时间, 机器数量也多(P)，但是同步数据需要时间，所以不能再正常时间内响应，所以A就不满足 AP 满足的情况下，C不能满足的原因： 机器数量也多(P)，正常的时间内响应(A)，那么数据就不能及时同步到其他节点，所以C不满足注册中心选择Zookeeper CP设计，保证了一致性，集群搭建的时候，某个节点失效，则会进行选举行的leader，或者半数以上节点不可用，则无法提供服务，因此可用性没法满足 Eureka AP原则，无主从节点，一个节点挂了，自动切换其他节点可以使用，去中心化 结论：分布式系统中P,肯定要满足，所以只能在CA中二选一 没有最好的选择，最好的选择是根据业务场景来进行架构设计 如果要求一致性，则选择zookeeper，如金融行业 如果要去可用性，则Eureka，如电商系统SpringCloud微服务核心组件Eureka介绍和闭源后影响SpringCloud体系介绍官方地址：http://projects.spring.io/spring-cloud/ Eureka 2.x闭源后选择参考：https://www.jianshu.com/p/d32ae141f680https://blog.csdn.net/zjcjava/article/details/78608892 项目代码，步骤详见github项目eureka服务端：https://github.com/zhengwx1991/eureka_service.giteureka客户端：https://github.com/zhengwx1991/product_service.git 遇到的问题问题：eureka管理后台出现一串红色字体：是警告，说明有服务上线率低 EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY&apos;RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. 关闭检查方法：eureka服务端配置文件加入 server: enable-self-preservation: false 注意：自我保护模式禁止关闭，默认是开启状态true，建议不进行关闭 问题二：为什么只加一个注册中心地址，就可以注册 官网解释： https://cloud.spring.io/spring-cloud-netflix/reference/html/#netflix-eureka-client-starter Note that the preceding example shows a normal Spring Boot application. By having spring-cloud-starter-netflix-eureka-client on the classpath, your application automatically registers with the Eureka Server. Configuration is required to locate the Eureka server, as shown in the following example: 请注意，前面的示例显示了一个普通的Spring Boot应用程序。通过spring-cloud-starter-netflix-eureka-client在类路径上，您的应用程序会自动向Eureka Server注册。找到Eureka服务器需要进行配置，如以下示例所示： application.yml eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/","link":"/2019/10/10/SpringCloud系列-1-注册中心Eureka/"},{"title":"SpringBoot系列--整合Mybatis","text":"项目地址https://github.com/zhengwx1991/spring-boot-demo.git SpringBoot整合Mybatis引入依赖12345678910111213141516171819202122&lt;!--SpringBoot整合Mybatis开始--&gt;&lt;!-- 引入starter--&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- MySQL的JDBC驱动包 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- 引入第三方数据源 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.6&lt;/version&gt;&lt;/dependency&gt;&lt;!--SpringBoot整合Mybatis结束--&gt; 配置数据库连接1234567891011121314spring: # 配置mysql数据库 datasource: url: jdbc:mysql://192.168.56.105:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8 username: root password: root # 默认数据源为（com.zaxxer.hikari.HikariDataSource） # 配置第三方数据源，如下阿里巴巴的druid type: com.alibaba.druid.pool.DruidDataSource# 开启控制台打印sql，一般用于本地开发测试部署时应注释掉mybatis: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl 启动类增加mapper扫描1234567@SpringBootApplication@MapperScan(\"com.sysware.mybatis.mapper\")public class SpringBootDemoApplication { public static void main(String[] args) { SpringApplication.run(SpringBootDemoApplication.class, args); }} 开发mapper参考语法：http://www.mybatis.org/mybatis-3/zh/java-api.html 相关资料：http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/#Configuration https://github.com/mybatis/spring-boot-starter/tree/master/mybatis-spring-boot-samples 整合问题集合：https://my.oschina.net/hxflar1314520/blog/1800035 https://blog.csdn.net/tingxuetage/article/details/80179772 事务、隔离级别、传播行为常见的隔离级别Serializable： 最严格，串行处理，消耗资源大Repeatable Read：保证了一个事务不会修改已经由另一个事务读取但未提交（回滚）的数据Read Committed：大多数主流数据库的默认事务等级Read Uncommitted：保证了读取过程中不会读取到非法数据 常见的传播行为PROPAGATION_REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务,最常见的选择PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行PROPAGATION_MANDATORY：支持当前事务，如果当前没有事务，就抛出异常PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起, 两个事务之间没有关系，一个异常，一个提交，不会同时回滚PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常 Mybatis引入事务service的实现类引入事务 ，可用作整个类也可以用于指定的的方法@Transantional(propagation=Propagation.REQUIRED) 12345678910111213@Override@Transactional(propagation = Propagation.REQUIRED)public int testTransaction() { User user = new User(); user.setAge(9); user.setCreateTime(new Date()); user.setName(\"事务测试\"); user.setPhone(\"000121212\"); userMapper.insert(user); // 加入异常 int a = 1/0; return user.getId();}","link":"/2018/09/07/SpringBoot系列-7-Mybatis/"},{"title":"SpringCloud系列-降级熔断Hystrix","text":"官方文档https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.strategyhttps://github.com/Netflix/Hystrixhttps://github.com/Netflix/Hystrix/wikihttps://github.com/Netflix/Hystrix/wiki/Dashboard 项目地址https://github.com/zhengwx1991/order_service.git 什么是分布式核心知识之熔断、降级1、熔断： 保险丝，熔断服务，为了防止整个系统故障，包含子和下游服务 下单服务 -》商品服务 -》用户服务 （出现异常-》熔断） 2、降级： 抛弃一些非核心的接口和数据 旅行箱的例子：只带核心的物品，抛弃非核心的，等有条件的时候再去携带这些物品 3、熔断和降级互相交集 相同点： 1）从可用性和可靠性触发，为了防止系统崩溃 2）最终让用户体验到的是某些功能暂时不能用 不同点 1）服务熔断一般是下游服务故障导致的，而服务降级一般是从整体系统负荷考虑，由调用方控制Netflix开源组件断路器Hystrix介绍文档地址： https://github.com/Netflix/Hystrix https://github.com/Netflix/Hystrix/wiki 1、什么是Hystrix？ 1）hystrix对应的中文名字是“豪猪” 2、为什么要用？ 在一个分布式系统里，一个服务依赖多个服务，可能存在某个服务调用失败， 比如超时、异常等，如何能够保证在一个依赖出问题的情况下，不会导致整体服务失败， 通过Hystrix就可以解决 http://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_circuit_breaker_hystrix_clients 3、提供了熔断、隔离、Fallback、cache、监控等功能 4、熔断后怎么处理？ 出现错误之后可以 fallback 错误的处理信息 兜底数据Feign结合Hystrix断路器开发（上）1、加入依赖 注意：网上新旧版本问题，所以要以官网为主，不然部分注解会丢失，最新版本 2.0 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; 2、增加注解 启动类里面增加注解 @EnableCircuitBreaker 注解越来越多-》 可以用@SpringCloudApplication注解代替，里边包含了众多springcloud的注解，如果想要知道自己用了哪些注解，也可以单独写，不用@SpringCloudApplication 3、API接口编码实战 熔断-》降级 1）最外层api使用，好比异常处理（网络异常，参数或者内部调用问题） api方法上增加 @HystrixCommand(fallbackMethod = &quot;saveOrderFail&quot;) 编写fallback方法实现，方法签名一定要和api方法签名一致（注意点！！！）Feign结合Hystrix断路器开发（下）1、feign结合Hystrix 1）开启feign支持hystrix (注意，一定要开启，旧版本默认支持，新版本默认关闭) feign: hystrix: enabled: true 2）FeignClient(name=&quot;xxx&quot;, fallback=xxx.class ), class需要继承当前FeignClient的类熔断降级服务异常报警通知实战完善服务熔断处理，报警机制完善 1、加入redis依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; 2、配置redis链接信息 redis: database: 0 host: 127.0.0.1 port: 6379 timeout: 2000 3、使用 //监控报警 String saveOrderKye = &quot;save-order&quot;; String sendValue = redisTemplate.opsForValue().get(saveOrderKye); final String ip = request.getRemoteAddr(); new Thread( ()-&gt;{ if (StringUtils.isBlank(sendValue)) { System.out.println(&quot;紧急短信，用户下单失败，请离开查找原因,ip地址是=&quot;+ip); //发送一个http请求，调用短信服务 TODO redisTemplate.opsForValue().set(saveOrderKye, &quot;save-order-fail&quot;, 20, TimeUnit.SECONDS); }else{ System.out.println(&quot;已经发送过短信，20秒内不重复发送&quot;); } }).start();源码分析Hystrix降级策略和调整1、查看默认讲解策略 HystrixCommandProperties 1）execution.isolation.strategy 隔离策略 THREAD 线程池隔离 （默认） SEMAPHORE 信号量 信号量适用于接口并发量高的情况，如每秒数千次调用的情况，导致的线程开销过高，通常只适用于非网络调用，执行速度快 2）execution.isolation.thread.timeoutInMilliseconds 超时时间，默认 1000毫秒 3）execution.timeout.enabled 是否开启超时限制 （一定不要禁用） 4）execution.isolation.semaphore.maxConcurrentRequests 隔离策略为 信号量的时候，如果达到最大并发数时，后续请求会被拒绝，默认是10 官方文档: https://github.com/Netflix/Hystrix/wiki/Configuration#execution.isolation.strategy 2、调整策略 超时时间调整 hystrix: command: default: execution: isolation: thread: timeoutInMilliseconds: 4000断路器Dashboard监控仪表盘使用断路器Dashboard基础使用和查看，开发时也可以不用这个，作为拓展 1、加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; 2、启动类增加注解 @EnableHystrixDashboard 3、配置文件增加endpoint management: endpoints: web: exposure: include: &quot;*&quot; 4、访问入口 http://localhost:8781/hystrix Hystrix Dashboard输入： http://localhost:8781/actuator/hystrix.stream 参考资料 默认开启监控配置 https://docs.spring.io/spring-boot/docs/current-SNAPSHOT/reference/htmlsingle/#boot-features-security-actuator 配置文件类：spring-configuration-metadata.json断路器监控仪表参数讲解和模拟熔断断路器监控仪表盘参数和模拟熔断 1、sse server-send-event推送到前端 资料：https://github.com/Netflix/Hystrix/wiki/Dashboard","link":"/2018/10/12/SpringCloud系列-10-降级熔断Hystrix/"},{"title":"SpringCloud系列-链路追踪系统Sleuth和ZipKin","text":"微服务下的链路追踪什么是分布式链路追踪系统，及使用好处 SpringCloud的链路追踪组件Sleuth分布式链路追踪组件Sleuth 1、官方文档 http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#sleuth-adding-project 2、什么是Sleuth 一个组件，专门用于记录链路数据的开源组件 [order-service,96f95a0dd81fe3ab,852ef4cfcdecabf3,false] 1、第一个值，spring.application.name的值 2、第二个值，96f95a0dd81fe3ab ，sleuth生成的一个ID，叫Trace ID，用来标识一条请求链路，一条请求链路中包含一个Trace ID，多个Span ID 3、第三个值，852ef4cfcdecabf3、spanid 基本的工作单元，获取元数据，如发送一个http 4、第四个值：false，是否要将该信息输出到zipkin服务中来收集和展示。 3、添加依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-sleuth&lt;/artifactId&gt; &lt;/dependency&gt;SpringCloud的链路追踪组件Sleuth常见问题说明分布式链路追踪组件Sleuth常见问题说明可视化链路追踪系统Zipkin部署1、什么是zipkin 官网：https://zipkin.io/ 大规模分布式系统的APM工具（Application Performance Management）,基于Google Dapper的基础实现，和sleuth结合可以提供可视化web界面分析调用链路耗时情况 2、同类产品 鹰眼（EagleEye） CAT twitter开源zipkin，结合sleuth Pinpoint，运用JavaAgent字节码增强技术 StackDriver Trace (Google) 3、开始使用 https://github.com/openzipkin/zipkin https://zipkin.io/pages/quickstart.html zipkin组成：Collector、Storage、Restful API、Web UI组成 4、知识拓展：OpenTracing OpenTracing 已进入 CNCF，正在为全球的分布式追踪，提供统一的概念和数据标准。 通过提供平台无关、厂商无关的 API，使得开发人员能够方便的添加（或更换）追踪系统的实现。 推荐阅读： http://blog.daocloud.io/cncf-3/ https://www.zhihu.com/question/27994350 https://yq.aliyun.com/articles/514488?utm_content=m_43347链路追踪组件Zipkin+Sleuth使用Zipkin+Sleuth业务分析调用链路分析 1、文档 http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_sleuth_with_zipkin_via_http sleuth收集跟踪信息通过http请求发送给zipkin server，zipkinserver进行跟踪信息的存储以及提供Rest API即可，Zipkin UI调用其API接口进行数据展示 默认存储是内存，可也用mysql、或者elasticsearch等存储 2、加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt; &lt;/dependency&gt; 里面包含 spring-cloud-starter-sleuth、spring-cloud-sleuth-zipkin 3、文档说明 http://cloud.spring.io/spring-cloud-static/Finchley.SR1/single/spring-cloud.html#_features_2 4、配置zipkin.base-url 5、配置采样百分闭spring.sleuth.sampler 推荐资料：https://blog.csdn.net/jrn1012/article/details/77837710","link":"/2018/10/14/SpringCloud系列-15-链路追踪系统Sleuth和ZipKin/"},{"title":"SpringCloud系列-网关Zuul","text":"项目地址https://github.com/zhengwx1991/api-gateway.git 微服务网关介绍和使用场景1）什么是网关 API Gateway，是系统的唯一对外的入口，介于客户端和服务器端之间的中间层，处理非业务功能 提供路由请求、鉴权、监控、缓存、限流等功能 统一接入 智能路由 AB测试、灰度测试 负载均衡、容灾处理 日志埋点（类似Nignx日志） 流量监控 限流处理 服务降级 安全防护 鉴权处理 监控 机器网络隔离 2）主流的网关 zuul：是Netflix开源的微服务网关，和Eureka,Ribbon,Hystrix等组件配合使用，Zuul 2.0比1.0的性能提高很多 kong: 由Mashape公司开源的，基于Nginx的API gateway nginx+lua：是一个高性能的HTTP和反向代理服务器,lua是脚本语言，让Nginx执行Lua脚本，并且高并发、非阻塞的处理各种请求SpringCloud的网关组件zuul基本使用1、加入依赖 2、启动类加入注解 @EnableZuulProxy 默认集成断路器 @EnableCircuitBreaker 默认访问规则 http://gateway:port/service-id/** 例子：默认 /order-service/api/v1/order/save?user_id=2&amp;product_id=1 自定义 /xdclass_order/api/v1/order/save?user_id=2&amp;product_id=1 自定义路由转发： zuul: routes: order-service: /apigateway/** 环境隔离配置： 需求 ：不想让默认的服务对外暴露接口 /order-service/api/v1/order/save 配置： zuul: ignored-patterns: - /*-service/api/v1/order/save高级篇幅之Zuul常用问题分析和网关过滤器原理分析1、路由名称定义问题 路由映射重复覆盖问题 2、Http请求头过滤问题 3、过滤器执行顺序问题 ，过滤器的order值越小，越先执行 4、共享RequestContext，上下文对象自定义Zuul过滤器实现登录鉴权实战1、新建一个filter包 2、新建一个类，实现ZuulFilter，重写里面的方法 3、在类顶部加注解，@Component,让Spring扫描高级篇幅之高并发情况下接口限流特技谷歌guava框架，网关限流使用 1、nginx层限流 2、网关层限流Zuul微服务网关集群搭建微服务网关Zull集群搭建 1、nginx+lvs+keepalive https://www.cnblogs.com/liuyisai/p/5990645.html","link":"/2018/10/15/SpringCloud系列-20-网关zuul/"},{"title":"SpringCloud系列-消息总线Bus","text":"官方文档http://cloud.spring.io/spring-cloud-bus/single/spring-cloud-bus.html#_bus_refresh_endpoint 消息总线Bus介绍和使用场景1、什么是消息总线​ 一个事件，需要广播或者单独传递给某个接口 2、为什么使用这个​ 配置更新了，但是其他系统不知道是否更新 消息队列RabbitMQ1、消息队列介绍https://www.cnblogs.com/linjiqin/p/5720865.html 2、同类产品KafkaActiveMQRocketMQ 3、SpringCloud默认推荐使用RabbitMQ 4、RabbitMQ介绍官方文档：http://www.rabbitmq.com/getstarted.html中文文档：http://rabbitmq.mr-ping.com/ 使用Docker搭建RabbitMQ简装方式有多种，推荐使用docker安装，极为方便 安装步骤： 1)拉取镜像 docker pull rabbitmq:management 2)查看当前镜像列表 docker images 3)删除指定镜像 docker rmi -f IMAGE_ID (如果需要强制删除加 -f) 4)创建容器 docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management 参数讲解: run: 创建一个新的容器并运行一个命令 -d: 后台运行容器，并返回容器ID -p: 端口映射，格式为：主机(宿主)端口:容器端口 --name=&quot;rabbitmq&quot;: 为容器指定一个名称 注意：RabbitMQ默认创建了一个 guest 用户，密码也是 guest, 如果访问不了记得查看防火墙，端口或者云服务器的 管理后台: http://127.0.0.1:15672 其他安装方式： Linux安装：https://blog.csdn.net/qq_34021712/article/details/72567786 windows安装：http://www.rabbitmq.com/install-windows.html https://blog.csdn.net/liyuejin/article/details/78410586总线Bus整合配置中心config操作流程1、启动rabbitmqdocker run -d –name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:management 2、config-client加入依赖123456789 &lt;!--配置中心结合消息队列--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 3、在配置文件application.yml中配置连接RabbitMQ(如果是本机，则可以直接启动，采用默认连接配置) 12345678910111213spring: rabbitmq: host: localhost port: 5672 username: guest password: guest#暴露全部的监控信息management: endpoints: web: exposure: include: \"*\" 4、需要刷新配置的地方，增加注解1@RefreshScope 5、访问验证post方式http://localhost:8773/actuator/bus-refresh 6、动态刷新配置在开发和测试环境使用，尽量少在生产环境使用,方式更新出问题，各个系统更新不一致造成更大的问题，尽量还是要相关的系统重新启动拉取最新配置。也防止系统被攻击，被攻击了系统配置导致全部系统都受影响 微服务相关项目改造配置中心1、git里面新增对应项目的配置文件，都要添加下面的配置1234567891011121314#服务的名称 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest#暴露全部的监控信息management: endpoints: web: exposure: include: \"*\" 2、项目里面添加maven依赖1234567891011121314&lt;!--配置中心客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--config server--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; 3、修改application.properties为bootstrap.yml并拷贝配置文件12345678910111213141516#指定注册中心地址eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/#服务的名称spring: application: name: order-service#指定从哪个配置中心读取cloud: config: discovery: service-id: CONFIG-SERVER enabled: true profile: test 4、各个项目启动顺序1）注册中心2）配置中心3）对应的服务：商品服务、订单服务。。。4）启动网关","link":"/2018/10/17/SpringCloud系列-30-消息总线Bus/"},{"title":"SpringCloud系列-配置中心Config","text":"官方文档服务端开发：http://cloud.spring.io/spring-cloud-config/客户端开发：http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html#_spring_cloud_config_client 项目地址配置中心服务端：https://github.com/zhengwx1991/config-server.git配置中心：https://github.com/zhengwx1991/config-cloud.git 微服务下的分布式配置中心什么是配置中心及使用前后的好处 什么是配置中心： 一句话：统一管理配置, 快速切换各个环境的配置 相关产品： 百度的disconf 地址:https://github.com/knightliao/disconf 阿里的diamand 地址：https://github.com/takeseem/diamond springcloud的configs-server: 地址：http://cloud.spring.io/spring-cloud-config/ 推荐干货文章：http://jm.taobao.org/2016/09/28/an-article-about-config-center/SpringCloud的配置中心组件config-server开发SpringCloud配置中心config-server开发 1、新建项目，创建config-server 2、启动类增加注解 @EnableConfigServer使用git服务器结合Config搭建分布式配置中心使用git服务器结合Config搭建分布式配置中心 1、默认使用git存储配置中心 使用git服务器，可以自己搭建gitlab服务器 或者使用github、开源中国git、阿里云git 2、配置文件添加配置 spring: application: name: config-server #git配置 cloud: config: server: git: uri: https://gitee.com/waitforxy/config_cloud username: github用户名 password: 登陆密码 #超时时间 timeout: 5 #分支 default-label: master 3、访问方式（一定要注意语法，如果有问题，会出错） 多种访问路径，可以通过启动日志去查看 例子 http://localhost:9100/product-service.yml /{name}-{profiles}.properties /{name}-{profiles}.yml /{name}-{profiles}.json /{label}/{name}-{profiles}.yml name 服务器名称 profile 环境名称，开发、测试、生产 lable 仓库分支、默认master分支分布式配置中心客户端使用微服务里面客户端接入配置中心开发 官方文档：http://cloud.spring.io/spring-cloud-config/single/spring-cloud-config.html#_spring_cloud_config_client 1、加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-client&lt;/artifactId&gt; &lt;/dependency&gt; 2、修改对应服务的配置文件,把application.yml 改为 bootstrap.yml #指定注册中心地址 eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ #服务的名称 spring: application: name: product-service #指定从哪个配置中心读取 cloud: config: discovery: service-id: CONFIG-SERVER enabled: true profile: test #建议用lable去区分环境，默认是lable是master分支 #label: test 注意点： 1.配置文件要用bootstrap.yml 2.默认读取文件名是 服务名称","link":"/2018/10/16/SpringCloud系列-25-配置中心Config/"},{"title":"SpringCloud系列——Feign","text":"官方文档https://cloud.spring.io/spring-cloud-static/spring-cloud-openfeign 项目路径https://github.com/zhengwx1991/order_service.git 常用的服务间调用方式RPC: 远程过程调用，像调用本地服务(方法)一样调用服务器的服务 支持同步、异步调用 客户端和服务器之间建立TCP连接，可以一次建立一个，也可以多个调用复用一次链接 PRC数据包小 protobuf thrift rpc：编解码，序列化，链接，丢包，协议 Rest(Http): http请求，支持多种协议和功能 开发方便成本低 http数据包大 java开发：HttpClient，URLConnection微服务调用方式之ribbon开发，订单调用商品服务订单服务 调用商品服务获取商品信息 1、创建order_service项目 2、开发伪下单接口 3、使用ribbon. (类似httpClient,URLConnection) 启动类增加注解 @Bean @LoadBalanced public RestTemplate restTemplate() { return new RestTemplate(); } 4、根据名称进行调用商品，获取商品详情 1、创建order_service项目 2、开发伪下单接口 3、使用ribbon. (类似httpClient,URLConnection) 启动类增加注解 @Bean @LoadBalanced public RestTemplate restTemplate(){ return new RestTemplate(); } 4、根据名称进行调用商品，获取商品详情 @Autowired private RestTemplate restTemplate; Map&lt;String, Object&gt; productMap = restTemplate.getForObject(&quot;http://PRODUCT-SERVICE/api/v1/product/find?id=&quot;+productId, Map.class);Ribbon负载均衡源码分析1、完善下单接口 2、分析@LoadBalanced 1）首先从注册中心获取provider的列表 2）通过一定的策略选择其中一个节点 3）再返回给restTemplate调用服务间调用之负载均衡策略调整自定义负载均衡策略：http://cloud.spring.io/spring-cloud-static/Finchley.RELEASE/single/spring-cloud.html#_customizing_the_ribbon_client_by_setting_properties 在配置文件yml里面，自定义负载均衡策略 #自定义负载均衡策略 product-service: ribbon: NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule 策略选择： 1、如果每个机器配置一样，则建议不修改策略 (推荐) 2、如果部分机器配置强，则可以改为 WeightedResponseTimeRule 微服务调用方式之 feign 实战 订单调用商品服务Feign： 伪RPC客户端(本质还是用http)1、使用feign步骤讲解（新旧版本依赖名称不一样） 加入依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 启动类增加@EnableFeignClients 增加一个接口 并@FeignClient(name=&quot;product-service&quot;) 2、注意点： 1、路径 2、Http方法必须对应 3、使用requestBody，应该使用@PostMapping 4、多个参数的时候，通过@RequestParam（&quot;id&quot;) int id)方式调用Feign核心源码解读和服务调用方式ribbon和Feign选择1、ribbon和feign两个的区别和选择 选择feign 默认集成了ribbon 写起来更加思路清晰和方便 采用注解方式进行配置，配置熔断等方式方便 2、超时配置 默认optons readtimeout是60，但是由于hystrix默认是1秒超时 #修改调用超时时间 feign: client: config: default: connectTimeout: 2000 readTimeout: 2000 模拟接口响应慢，线程睡眠新的方式 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }","link":"/2018/10/11/SpringCloud系列-5-Feign/"},{"title":"sourcetree（企业版）跳过验证安装","text":"软件介绍适用于Windows和Mac的免费Git可视化客户端Sourcetree简化了您与Git存储库交互的方式，因此您可以专注于编码。通过Sourcetree的简单Git GUI可视化和管理您的存储库。 下载企业版https://www.sourcetreeapp.com/enterprise 设置跳过验证 进入C:\\Users\\用户\\AppData\\Local\\Atlassian\\SourceTree目录 注意：用户名是自己电脑的，可能是Administrator,也可能是自己自定义的，电脑名不要设置为中文。 在该目录下新增文件accounts.json 将一下内容粘贴到文件中 123456789101112131415161718192021222324[ { \"$id\": \"1\", \"$type\": \"SourceTree.Api.Host.Identity.Model.IdentityAccount, SourceTree.Api.Host.Identity\", \"Authenticate\": true, \"HostInstance\": { \"$id\": \"2\", \"$type\": \"SourceTree.Host.Atlassianaccount.AtlassianAccountInstance, SourceTree.Host.AtlassianAccount\", \"Host\": { \"$id\": \"3\", \"$type\": \"SourceTree.Host.Atlassianaccount.AtlassianAccountHost, SourceTree.Host.AtlassianAccount\", \"Id\": \"atlassian account\" }, \"BaseUrl\": \"https://id.atlassian.com/\" }, \"Credentials\": { \"$id\": \"4\", \"$type\": \"SourceTree.Model.BasicAuthCredentials, SourceTree.Api.Account\", \"Username\": \"\", \"Email\": null }, \"IsDefault\": false }] 安装点击安装包正常安装即可","link":"/2019/05/26/sourcetree（企业版）跳过验证安装/"},{"title":"Linux安装Nexus","text":"下载https://www.sonatype.com/oss-thank-you-tar.gz","link":"/2018/09/09/Linux安装Maven私服/"},{"title":"Linux安装MySQL","text":"下载MySQLwget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm安装mysql源yum -y localinstall mysql57-community-release-el7-11.noarch.rpm 安装mysqlyum -y install mysql-community-server启动systemctl start mysqld设置开机启动systemctl enable mysqld systemctl daemon-reload修改root本地登录密码vi /etc/my.cnf 在[mysqld]后面任意一行添加&quot;&quot;用来跳过密码验证的过程 skip-grant-tables vi /var/log/mysqld.log password 改成!TestTest // root 登陆 mysql -u root -p ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;!Test123456&apos;;设置允许远程登录flush privileges; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;!TestTest&apos; WITH GRANT OPTION; exit;设置防火墙firewall-cmd --zone=public --add-port=3306/tcp --permanent // 刷新防火墙规则 firewall-cmd --reload // 验证端口,查询防火墙开放端口 firewall-cmd --zone=public --list-port // 重启防火墙 systemctl restart firewalld.service配置默认编码为UTF-8vi /etc/my.cnf [mysqld] character_set_server=utf8 init_connect=&apos;SET NAMES utf8&apos; // 重启服务 systemctl restart mysqld // 查看编码 show variables like &apos;%character%&apos;;","link":"/2018/09/09/Linux安装MySQL/"},{"title":"Linux安装Docker及应用","text":"安装详见Dockerhttps://www.runoob.com/docker/centos-docker-install.html 阿里云安装手册： https://help.aliyun.com/document_detail/51853.html?spm=a2c4g.11186623.6.820.RaToNY 常见问题： https://blog.csdn.net/daluguishou/article/details/52080250 Docker 安装 Redis查询 docker search redis 拉取 docker pull redis 启动镜像 docker run -p 6379:6379 -v $PWD/data:/data -d redis redis-server --appendonly yes docker run -p 6379:6379 -v $PWD/data:/data -d --name reids [镜像ID] redis-server --appendonly yes 命令说明： -p 6379:6379 : 将容器的6379端口映射到主机的6379端口 -v $PWD/data:/data : 将主机中当前目录下的data挂载到容器的/data redis-server --appendonly yes : 在容器执行redis-server启动命令，并打开redis持久化配置Docker 安装RabbitMQ查询 docker search rabbitmq 拉取 docker pull rabbitmq:management 启动镜像 docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 rabbitmq:managementDocker部署Nginx服务器简介：讲解使用Docker部署Nginx服务器实战 1、获取镜像 docker run (首先会从本地找镜像，如果有则直接启动，没有的话，从镜像仓库拉起，再启动) docker search nignx 2、列举 docker images 3、拉取 docker pull nignx 3、启动 docker run -d --name &quot;xdclass_nginx&quot; -p 8088:80 nginx docker run -d --name &quot;xdclass_nginx2&quot; -p 8089:80 nginx docker run -d --name &quot;xdclass_nginx3&quot; -p 8090:80 nginx 4、访问 如果是阿里云服务，记得配置安全组，腾讯云也需要配置，这个就是一个防火墙微服务下的Docker介绍和使用场景什么是Dokcer百科:一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口； 使用go语言编写，在LCX（linux容器）基础上进行的封装 简单来说： 1）就是可以快速部署启动应用 2）实现虚拟化，完整资源隔离 3）一次编写，四处运行（有一定的限制，比如Docker是基于Linux 64bit的，无法在32bit的linux/Windows/unix环境下使用）为什么要用Dokcer1、提供一次性的环境，假如需要安装Mysql，则需要安装很多依赖库、版本等，如果使用Docker则通过镜像就可以直接启动运行 2、快速动态扩容，使用docker部署了一个应用，可以制作成镜像，然后通过Dokcer快速启动 3、组建微服务架构，可以在一个机器上模拟出多个微服务，启动多个应用 4、更好的资源隔离和共享 一句话：开箱即用，快速部署，可移植性强，环境隔离Docker仓库、镜像、容器核心知识Docker 镜像 - Docker images：容器运行时的只读模板，操作系统+软件运行环境+用户程序 可以类比为Java中的类Class class User{ private String userName; private int age; } Docker 容器 - Docker containers：容器包含了某个应用运行所需要的全部环境 可以类比为Java中的对象Object User user = new User() Docker 仓库 - Docker registeries： 用来保存镜像，有公有和私有仓库，好比Maven的中央仓库和本地私服 镜像仓库：（参考）配置国内镜像仓库：https://blog.csdn.net/zzy1078689276/article/details/77371782 对比面向对象的方式 Dokcer 里面的镜像 : Java里面的类 Class Docker 里面的容器 : Java里面的对象 Object 通过类创建对象，通过镜像创建容器Docker容器常见命令启动docker： systemctl start docker 开机启动docker： systemctl enable docker 停止docker： systemctl stop docker Docker在云服务上的实际应用 常用命令（安装部署好Dokcer后，执行的命令是docker开头）,xxx是镜像名称 搜索镜像：docker search xxx 列出当前系统存在的镜像：docker images 拉取镜像：docker pull xxx xxx是具体某个镜像名称(格式 REPOSITORY:TAG) REPOSITORY：表示镜像的仓库源,TAG：镜像的标签 运行一个容器：docker run -d --name &quot;xdclass_mq&quot; -p 5672:5672 -p 15672:15672 rabbitmq:management docker run - 运行一个容器 -d 后台运行 -p 端口映射 rabbitmq:management (格式 REPOSITORY:TAG)，如果不指定tag，默认使用最新的 --name &quot;xxx&quot; 列举当前运行的容器：docker ps 检查容器内部信息：docker inspect 容器名称 删除镜像：docker rmi IMAGE_NAME 强制移除镜像不管是否有容器使用该镜像 增加 -f 参数， 停止某个容器：docker stop 容器名称 启动某个容器：docker start 容器名称 移除某个容器： docker rm 容器名称 （容器必须是停止状态） 文档：https://blog.csdn.net/permike/article/details/51879578公司中Docker镜像仓库使用1、为啥要用镜像仓库 2、官方公共镜像仓库和私有镜像仓库 公共镜像仓库： 官方：https://hub.docker.com/，基于各个软件开发或者有软件提供商开发的 非官方：其他组织或者公司开发的镜像，供大家免费试用 私有镜像仓库： 用于存放公司内部的镜像，不提供给外部试用； SpringCloud 开发了一个支付系统 -》做成一个镜像 （操作系统+软件运行环境+用户程序）阿里云搭建自己的镜像仓库1、阿里云镜像仓库：https://dev.aliyun.com/search.html 点击管理控制台-》初次使用会提示开通，然后设置密码 2、使用阿里云私有镜像仓库 1)登录： docker login --username=794666918@qq.com registry.cn-shenzhen.aliyuncs.com 2) 推送本地镜像： docker tag [ImageId] registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:[镜像版本号] 例子： docker tag 2f415b0e9a6e registry.cn-shenzhen.aliyuncs.com/test/sysware_images:rabbitmq-v1.0.2 docker push registry.cn-shenzhen.aliyuncs.com/xdclass/sysware_images:rabbitmq-v1.0.2 3)拉取镜像 线上服务器拉取镜像： docker login --username=794666918@qq.com registry.cn-shenzhen.aliyuncs.com docker pull registry.cn-shenzhen.aliyuncs.com/sysware_images:xd_rabbitmq-v1.0.2 启动容器： docker run -d --name rabbitmq -p 5672:5672 -p 15672:15672 2f415b0e9a6eSpringCloud和Docker整合部署使用Docker的maven插件，构建springboot应用官方文档：https://spring.io/guides/gs/spring-boot-docker/ 1、步骤：maven里面添加配置pom.xml &lt;properties&gt; &lt;docker.image.prefix&gt;xdclass&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;finalName&gt;docker-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 配置说明 Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。 ${project.build.finalName} 产出物名称，缺省为${project.artifactId}-${project.version}打包SpringCloud镜像并上传私有仓库并部署1、创建Dockerfile,默认是根目录，（可以修改为src/main/docker/Dockerfile,如果修则需要制定路径） 什么是Dockerfile : 由一系列命令和参数构成的脚本，这些命令应用于基础镜像, 最终创建一个新的镜像 FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 参数讲解： FROM &lt;image&gt;:&lt;tag&gt; 需要一个基础镜像，可以是公共的或者是私有的， 后续构建会基于此镜像，如果同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令 VOLUME 配置一个具有持久化功能的目录，主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp。改步骤是可选的，如果涉及到文件系统的应用就很有必要了。/tmp目录用来持久化到 Docker 数据文件夹，因为 Spring Boot 使用的内嵌 Tomcat 容器默认使用/tmp作为工作目录 ARG 设置编译镜像时加入的参数， ENV 是设置容器的环境变量 COPY : 只支持将本地文件复制到容器 ,还有个ADD更强大但复杂点 ENTRYPOINT 容器启动时执行的命令 EXPOSE 8080 暴露镜像端口 2、构建镜像 mvn install dockerfile:build 打标签 docker tag a1b9fc71720d registry.cn-shenzhen.aliyuncs.com/sysware_images:docker-demo-v201808 推送到镜像仓库 docker push registry.cn-shenzhen.aliyuncs.com/sysware_images:docker-demo-v201808 应用服务器拉取镜像 docker pull registry.cn-shenzhen.aliyuncs.com/sysware_images:docker-demo-v201808 docker run -d --name xdclass_docker_demo1 -p 8099:8080 a1b9fc71720d 3、查看启动日志 docker logs -f containerid 文档：https://yeasy.gitbooks.io/docker_practice/image/dockerfile/注册中心打包Docker镜像使用Docker打包注册中心，上传私有镜像仓库并部署 1、新增maven插件 &lt;properties&gt; &lt;docker.image.prefix&gt;xdclass&lt;/docker.image.prefix&gt; &lt;/properties&gt; &lt;build&gt; &lt;finalName&gt;docker-demo&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;com.spotify&lt;/groupId&gt; &lt;artifactId&gt;dockerfile-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.6&lt;/version&gt; &lt;configuration&gt; &lt;repository&gt;${docker.image.prefix}/${project.artifactId}&lt;/repository&gt; &lt;buildArgs&gt; &lt;JAR_FILE&gt;target/${project.build.finalName}.jar&lt;/JAR_FILE&gt; &lt;/buildArgs&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 2、新建Dockerfile FROM openjdk:8-jdk-alpine VOLUME /tmp ARG JAR_FILE COPY ${JAR_FILE} app.jar ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;] 3、打包： mvn install dockerfile:build 4、推送阿里云镜像仓库 阿里云镜像仓库：https://dev.aliyun.com/search.html 5、查看日志 docker logs -f containerid生产环境常见问题之配置中心访问生产环境部署常见问题，配置中心访问路径变化 1、配置中心访问出错，路径不对 解决：修改所有的注册中心，增加下面配置 instance: instance-id: ${spring.cloud.client.ip-address}:${server.port} prefer-ip-address: true docker tag 50a12cd66210 registry.cn-shenzhen.aliyuncs.com/xdclass/xdclass_images:config-server-v20180826Docker镜像打包商品服务和订单服务、网关注意： 1、maven打包构建，会触发单元测试，部分情况可以跳过， mvn install -Dmaven.test.skip=true dockerfile:build 2、生产环境不能用localhost 或者 127.0.0.1, 一定要用内网通信ip (虚拟主机映射 hosts)","link":"/2019/05/27/Linux安装Docker/"}],"tags":[{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Jenkins","slug":"Jenkins","link":"/tags/Jenkins/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"GitHub","slug":"GitHub","link":"/tags/GitHub/"},{"name":"GitLab","slug":"GitLab","link":"/tags/GitLab/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"JDK","slug":"JDK","link":"/tags/JDK/"},{"name":"MAVEN","slug":"MAVEN","link":"/tags/MAVEN/"},{"name":"博客","slug":"博客","link":"/tags/博客/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"热部署","slug":"热部署","link":"/tags/热部署/"},{"name":"devtools","slug":"devtools","link":"/tags/devtools/"},{"name":"banner","slug":"banner","link":"/tags/banner/"},{"name":"定时任务","slug":"定时任务","link":"/tags/定时任务/"},{"name":"异步任务","slug":"异步任务","link":"/tags/异步任务/"},{"name":"多环境","slug":"多环境","link":"/tags/多环境/"},{"name":"LogBack","slug":"LogBack","link":"/tags/LogBack/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"SpringCloud","slug":"SpringCloud","link":"/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","link":"/tags/Eureka/"},{"name":"Mybatis","slug":"Mybatis","link":"/tags/Mybatis/"},{"name":"Hystrix","slug":"Hystrix","link":"/tags/Hystrix/"},{"name":"Sleuth","slug":"Sleuth","link":"/tags/Sleuth/"},{"name":"ZipKin","slug":"ZipKin","link":"/tags/ZipKin/"},{"name":"Zuul","slug":"Zuul","link":"/tags/Zuul/"},{"name":"Bus","slug":"Bus","link":"/tags/Bus/"},{"name":"Config","slug":"Config","link":"/tags/Config/"},{"name":"Feign","slug":"Feign","link":"/tags/Feign/"},{"name":"sourcetree","slug":"sourcetree","link":"/tags/sourcetree/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Nexus","slug":"Nexus","link":"/tags/Nexus/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"}],"categories":[{"name":"IDEA","slug":"IDEA","link":"/categories/IDEA/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"GitHub","slug":"GitHub","link":"/categories/GitHub/"},{"name":"JDK","slug":"Linux/JDK","link":"/categories/Linux/JDK/"},{"name":"Jenkins","slug":"Linux/Jenkins","link":"/categories/Linux/Jenkins/"},{"name":"Redis","slug":"Linux/Redis","link":"/categories/Linux/Redis/"},{"name":"博客","slug":"博客","link":"/categories/博客/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"},{"name":"RabbitMQ","slug":"Linux/RabbitMQ","link":"/categories/Linux/RabbitMQ/"},{"name":"MAVEN","slug":"Linux/JDK/MAVEN","link":"/categories/Linux/JDK/MAVEN/"},{"name":"SpringCloud","slug":"SpringCloud","link":"/categories/SpringCloud/"},{"name":"Maven","slug":"Linux/Maven","link":"/categories/Linux/Maven/"},{"name":"热部署","slug":"SpringBoot/热部署","link":"/categories/SpringBoot/热部署/"},{"name":"MySQL","slug":"Linux/MySQL","link":"/categories/Linux/MySQL/"},{"name":"banner","slug":"SpringBoot/banner","link":"/categories/SpringBoot/banner/"},{"name":"多环境","slug":"SpringBoot/多环境","link":"/categories/SpringBoot/多环境/"},{"name":"LogBack","slug":"SpringBoot/LogBack","link":"/categories/SpringBoot/LogBack/"},{"name":"http","slug":"SpringBoot/http","link":"/categories/SpringBoot/http/"},{"name":"Eureka","slug":"SpringCloud/Eureka","link":"/categories/SpringCloud/Eureka/"},{"name":"Mybatis","slug":"SpringBoot/Mybatis","link":"/categories/SpringBoot/Mybatis/"},{"name":"Hystrix","slug":"SpringCloud/Hystrix","link":"/categories/SpringCloud/Hystrix/"},{"name":"Sleuth","slug":"SpringCloud/Sleuth","link":"/categories/SpringCloud/Sleuth/"},{"name":"Zuul","slug":"SpringCloud/Zuul","link":"/categories/SpringCloud/Zuul/"},{"name":"Bus","slug":"SpringCloud/Bus","link":"/categories/SpringCloud/Bus/"},{"name":"Config","slug":"SpringCloud/Config","link":"/categories/SpringCloud/Config/"},{"name":"Feign","slug":"SpringCloud/Feign","link":"/categories/SpringCloud/Feign/"},{"name":"Nexus","slug":"Linux/Maven/Nexus","link":"/categories/Linux/Maven/Nexus/"},{"name":"ZipKin","slug":"SpringCloud/Sleuth/ZipKin","link":"/categories/SpringCloud/Sleuth/ZipKin/"},{"name":"Docker","slug":"Linux/Docker","link":"/categories/Linux/Docker/"}]}